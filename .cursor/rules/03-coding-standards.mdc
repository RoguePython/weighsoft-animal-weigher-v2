---
globs:
  - "**/*.ts"
  - "**/*.tsx"
  - "**/*.js"
  - "**/*.jsx"
alwaysApply: false
---

# Coding Standards

## TypeScript Standards

### Naming Conventions
- **Files**: kebab-case (e.g., `animal-weigher.ts`)
- **Components**: PascalCase (e.g., `AnimalWeigher.tsx`)
- **Interfaces**: PascalCase with 'I' prefix for contracts (e.g., `IAnimalRepository`)
- **Types**: PascalCase (e.g., `AnimalWeight`)
- **Functions/Methods**: camelCase (e.g., `getAnimalWeight`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_WEIGHT_KG`)
- **Private members**: prefix with underscore (e.g., `_privateMethod`)

### Type Safety
```typescript
// ✅ GOOD: Explicit types
function calculateWeight(value: number): number {
  return value * 2.2;
}

// ❌ BAD: Implicit any
function calculateWeight(value) {
  return value * 2.2;
}
```

### Interface vs Type
- Use `interface` for object shapes that might be extended
- Use `type` for unions, intersections, and primitives

### Async/Await
```typescript
// ✅ GOOD: Proper async handling
async function fetchAnimal(id: string): Promise<Animal> {
  try {
    const result = await repository.getById(id);
    return result;
  } catch (error) {
    throw new AnimalNotFoundException(id);
  }
}
```

## React Native Standards

### Component Structure
```tsx
// 1. Imports
import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet } from 'react-native';

// 2. Types/Interfaces
interface AnimalCardProps {
  animal: Animal;
  onPress: (id: string) => void;
}

// 3. Component
export const AnimalCard: React.FC<AnimalCardProps> = ({ animal, onPress }) => {
  // 3a. Hooks
  const [isLoading, setIsLoading] = useState(false);

  // 3b. Effects
  useEffect(() => {
    // Effect logic
  }, []);

  // 3c. Handlers
  const handlePress = () => {
    onPress(animal.id);
  };

  // 3d. Render
  return (
    <View style={styles.container}>
      <Text>{animal.name}</Text>
    </View>
  );
};

// 4. Styles
const styles = StyleSheet.create({
  container: {
    padding: 16,
  },
});
```

### Hooks Rules
- Custom hooks must start with `use`
- Keep hooks at the top of components
- Never call hooks conditionally

## Error Handling
```typescript
// Create specific exception classes
export class DatabaseException extends Error {
  constructor(message: string, public readonly cause?: Error) {
    super(message);
    this.name = 'DatabaseException';
  }
}

// Use try-catch with specific exceptions
try {
  await database.query(sql);
} catch (error) {
  throw new DatabaseException('Failed to execute query', error);
}
```

## Comments
- Use JSDoc for public APIs
- Avoid obvious comments
- Explain WHY, not WHAT
